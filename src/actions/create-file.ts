import {
  type Action,
  type Content,
  type HandlerCallback,
  type IAgentRuntime,
  type Memory,
  type State,
  logger,
} from '@elizaos/core';
import { ClaudeCodeService } from '../services/claude-code';
import { z } from 'zod';

const createFileSchema = z.object({
  fileName: z.string().describe('Name of the file to create'),
  filePath: z.string().optional().describe('Directory path where to create the file'),
  description: z.string().describe('Description of what the file should contain'),
  language: z.string().optional().describe('Programming language or file type'),
  template: z.string().optional().describe('Template or pattern to follow'),
  dependencies: z.array(z.string()).optional().describe('Required dependencies or imports'),
});

export const createFileAction: Action = {
  name: 'CREATE_FILE',
  similes: ['GENERATE_FILE', 'NEW_FILE', 'MAKE_FILE', 'WRITE_FILE'],
  description: 'Creates new files with code or content generated by Claude Code',

  validate: async (runtime: IAgentRuntime, message: Memory, state: State): Promise<boolean> => {
    const text = message.content.text?.toLowerCase() || '';
    
    // Check if the message contains file creation related keywords
    const createKeywords = ['create', 'generate', 'make', 'write', 'new', 'build', 'scaffold'];
    const fileKeywords = ['file', 'script', 'module', 'component', 'class', 'function', 'template'];
    
    const containsCreateKeyword = createKeywords.some(keyword => text.includes(keyword));
    const containsFileKeyword = fileKeywords.some(keyword => text.includes(keyword));
    
    return containsCreateKeyword && containsFileKeyword;
  },

  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state: State,
    _options: any,
    callback: HandlerCallback,
    _responses: Memory[]
  ) => {
    try {
      logger.info('Executing CREATE_FILE action');
      
      // Get Claude Code service
      const service = runtime.getService(ClaudeCodeService.serviceType) as ClaudeCodeService;
      if (!service) {
        throw new Error('Claude Code service not available');
      }

      // Parse the input
      const text = message.content.text || '';
      const params = await extractCreateFileParams(text);
      
      logger.debug('Create file parameters:', params);

      // Construct the creation prompt
      const creationPrompt = constructCreationPrompt(params);
      
      // Execute the file creation
      const messages = await service.executeQuery(creationPrompt, {
        maxTurns: 3,
        permissionMode: 'acceptEdits', // Allow file creation
      });
      
      // Extract the result from messages
      let creationResult = '';
      let fileCreated = false;
      
      for (const msg of messages) {
        if (msg.type === 'assistant') {
          creationResult += msg.message.content;
          // Check if file was actually created
          if (msg.message.content.includes('created') || msg.message.content.includes('wrote')) {
            fileCreated = true;
          }
        }
      }
      
      if (!creationResult) {
        throw new Error('No result received from Claude Code');
      }

      // Format the response
      const responseContent: Content = {
        text: formatCreationResponse(creationResult, params, fileCreated),
        actions: ['CREATE_FILE'],
        source: message.content.source,
        metadata: {
          fileName: params.fileName,
          filePath: params.filePath,
          language: params.language,
          created: fileCreated,
          timestamp: new Date().toISOString(),
        },
      };

      await callback(responseContent);
      return responseContent;
    } catch (error) {
      logger.error('Error in CREATE_FILE action:', error);
      
      const errorContent: Content = {
        text: `I encountered an error while creating the file: ${error.message}. Please check your request and try again.`,
        actions: ['CREATE_FILE'],
        source: message.content.source,
      };
      
      await callback(errorContent);
      return errorContent;
    }
  },

  examples: [
    [
      {
        name: '{{user}}',
        content: {
          text: 'Create a Python script that reads a CSV file and calculates statistics',
        },
      },
      {
        name: '{{agent}}',
        content: {
          text: 'I\'ll create a Python script that reads CSV files and calculates statistics.\n\nüìÑ **Created file: `csv_statistics.py`**\n\nThe script includes:\n- CSV file reading functionality\n- Statistical calculations (mean, median, mode, std deviation)\n- Error handling for file operations\n- Command-line argument support\n- Pretty output formatting\n\nKey features:\n```python\n# Calculates statistics for numeric columns\n# Usage: python csv_statistics.py data.csv\n# Supports multiple statistical measures\n```\n\nThe file has been created in your current directory. You can run it with:\n```bash\npython csv_statistics.py your_data.csv\n```',
          actions: ['CREATE_FILE'],
        },
      },
    ],
    [
      {
        name: '{{user}}',
        content: {
          text: 'Generate a React component for a user profile card with TypeScript',
        },
      },
      {
        name: '{{agent}}',
        content: {
          text: 'I\'ll create a TypeScript React component for a user profile card.\n\nüìÑ **Created file: `UserProfileCard.tsx`**\n\nThe component includes:\n- TypeScript interfaces for type safety\n- Props for user data (name, avatar, bio, etc.)\n- Responsive design with styled-components or CSS modules\n- Optional social media links\n- Loading and error states\n\nComponent structure:\n```typescript\ninterface UserProfileCardProps {\n  name: string;\n  avatar?: string;\n  bio?: string;\n  email?: string;\n  socialLinks?: SocialLink[];\n}\n```\n\nThe file has been created and is ready to use. Import it into your React application:\n```typescript\nimport UserProfileCard from \'./UserProfileCard\';\n```',
          actions: ['CREATE_FILE'],
        },
      },
    ],
  ],
};

// Helper functions

async function extractCreateFileParams(text: string): Promise<z.infer<typeof createFileSchema>> {
  const params: any = {};
  
  // Extract file name
  const fileNameMatch = text.match(/(?:called|named|file\s+)([a-zA-Z0-9_\-]+\.[a-zA-Z]+)/);
  if (fileNameMatch) {
    params.fileName = fileNameMatch[1];
  } else {
    // Try to infer from content type
    if (text.includes('python') || text.includes('script')) {
      params.fileName = 'script.py';
    } else if (text.includes('react') || text.includes('component')) {
      params.fileName = text.includes('typescript') ? 'Component.tsx' : 'Component.jsx';
    } else if (text.includes('html')) {
      params.fileName = 'index.html';
    } else {
      params.fileName = 'new_file.txt';
    }
  }
  
  // Extract language
  const languages = ['python', 'javascript', 'typescript', 'java', 'c++', 'c#', 'go', 'rust', 'ruby', 'php'];
  for (const lang of languages) {
    if (text.toLowerCase().includes(lang)) {
      params.language = lang;
      break;
    }
  }
  
  // Extract description
  params.description = text;
  
  // Extract file path if mentioned
  const pathMatch = text.match(/(?:in|at|to)\s+(?:the\s+)?(?:directory|folder|path)\s+([^\s]+)/);
  if (pathMatch) {
    params.filePath = pathMatch[1];
  }
  
  return createFileSchema.parse(params);
}

function constructCreationPrompt(params: z.infer<typeof createFileSchema>): string {
  const { fileName, filePath, description, language, template, dependencies } = params;
  
  let prompt = `Create a new file named "${fileName}"`;
  
  if (filePath) {
    prompt += ` in the directory "${filePath}"`;
  }
  
  prompt += `\n\nRequirements:\n${description}`;
  
  if (language) {
    prompt += `\n\nProgramming language: ${language}`;
  }
  
  if (template) {
    prompt += `\n\nFollow this template/pattern: ${template}`;
  }
  
  if (dependencies && dependencies.length > 0) {
    prompt += `\n\nInclude these dependencies/imports: ${dependencies.join(', ')}`;
  }
  
  prompt += '\n\nPlease create the file with appropriate content, following best practices for the language and including necessary imports, error handling, and documentation.';
  
  return prompt;
}

function formatCreationResponse(
  result: string, 
  params: z.infer<typeof createFileSchema>, 
  fileCreated: boolean
): string {
  if (fileCreated) {
    return `‚úÖ Successfully created file: **${params.fileName}**\n\n${result}`;
  } else {
    return `üìù File content generated for **${params.fileName}**:\n\n${result}\n\n*Note: You may need to manually save this content to a file.*`;
  }
} 